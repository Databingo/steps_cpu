 #!/bin/sh  

#################################################################
#
# Name: qt
# Copyright (c) 2013 Altera Corporation. All rights reserved.
# 
# Usage: qt
#
qt_script_ver=2.8
#
# Your use of Altera Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output files 
# any of the foregoing (including device programming or simulation files), and 
# any associated documentation or information are expressly subject to the terms 
# and conditions of the Altera Program License Subscription Agreement, Altera 
# MegaCore Function License Agreement, or other applicable license agreement, 
# including, without limitation, that your use is for the sole purpose of 
# programming logic devices manufactured by Altera and sold by Altera or its 
# authorized distributors.  Please refer to the applicable agreement for 
# further details.
#
# Revision history:
# 2.8 - 09/24/2003 Robert Romano
# 2.7 - 05/08/2003 Robert Romano
# 2.6 - 04/13/2002 Ben Twijnstra
# 2.5 - 04/25/2001 Adrian Drury
# 2.3 - 03/13/2001 Jeff Thomas, Adrian Drury
# 2.2 - 03/07/2001 Adrian Drury
# 2.1 - 02/08/2001 Adrian Drury
# 2.0 - 01/17/2001 Adrian Drury
# 1.4 - 03/16/2000 Sudhir Wadhwa
#
#################################################################

#################################################################
#
# Subroutine: drawBanner
#
# Author: Adrian Drury
#
# Arguments: none
#
# Function: displays Altera banner with copyright information
#
# Revision history:
# 01/17/2001 - Created
#################################################################

drawBanner() {

    clear
    echo "+------------------------------------------------------------------------------+" | tee -a $1
    echo "|                     __   _______________________     __                      |" | tee -a $1
    echo "|                    /  \  |  |__    __|__    __  \   /  \                     |" | tee -a $1
    echo "|                   /    \ |  |  |  |  |__|  |__)  | /    \                    |" | tee -a $1
    echo "|                  /  /\  \|  |  |  |   __    _   / /  /\  \                   |" | tee -a $1
    echo "|                 /  ____  \  |__|  |  |__|  | \  \/  ____  \                  |" | tee -a $1
    echo "|                /__/    \__________|________|  \____/    \__\                 |" | tee -a $1
    echo "|                                                                              |" | tee -a $1
    echo "|                    A L T E R A     C O R P O R A T I O N                     |" | tee -a $1
    echo "|                                                                              |" | tee -a $1
    echo "+------------------------------------------------------------------------------+" | tee -a $1
    echo "|     COPYRIGHT (c) ALTERA CORPORATION 2010.           ALL RIGHTS RESERVED.    |" | tee -a $1
    echo "+------------------------------------------------------------------------------+" | tee -a $1
    echo " "                                                                                | tee -a $1
    
    }

#################################################################
#
# Subroutine: printPurpose
#
# Author: Adrian Drury
#
# Arguments: none
#
# Function: prints the purpose of the qt script
#
# Revision history:
# 01/17/2001 - Created
#################################################################

printPurpose() {
    echo "*** QT v${qt_script_ver} ***"
    echo "This script checks system requirements for Altera software."
    echo ""
    echo "It checks available physical resources and installed patches and can email"
    echo "that information to Altera for troubleshooting purposes. No information is"
    echo "emailed automatically. You must specify an email address to use this feature."
    echo ""
}

#################################################################
#
# Subroutine: printUsageAndExit
#
# Author: Adrian Drury
#
# Arguments: none
#
# Function: prints the usage of the script and exits with 1
#
# Revision history:
# 01/17/2001 - Created
#################################################################

printUsageAndExit() {
    echo "qt script ver $qt_script_ver"
    echo "Usage: qt [OPTIONS]"
    echo ""    
    echo "   Options:"
    echo "   -h Print this information."
    echo "   -v This option makes the script output verbose."
    echo "   -n This option makes the script non-interactive. It never asks you"
    echo "        to hit return."
    echo "   -c <path to sys_reqs.txt> if you do not accept the default"
    echo "        location in the same directory as the script" 
    echo "   -t <name of temporary output file> if you do not accept the default"
    echo "        of /tmp/qt.out"
    echo "   -e <email address 1> <email address 2> <email address n>"
    echo "        This must be the LAST option specified on the command line."
    echo "        Everything after the -e is assumed to be a list of email addresses."
    echo ""
    exit 1
    }

#################################################################
#
# Subroutine: waitForReturn
#
# Author: Adrian Drury
#
# Arguments: one - whether or not to display the message and wait
#
# Function: prompts user to press return to continue
#
# Revision history:
# 01/17/2001 - Created
#################################################################

waitForReturn() {

    if [ $1 -eq 1 ]
    then
        echo "Press RETURN to continue"
        read ENTER
        clear
    fi
}

################################################################
#
# Beginning of script
#
################################################################

# Check to see if the user is root if on HP-UX

USER_PRIV=`id -un`
TEMP=`uname -s`
NOT_ROOT=0

if [ "$USER_PRIV" != "root" -a "$TEMP" = "HP-UX" ]
then
	NOT_ROOT=1

	clear
	echo ""
	echo "*** NOTE ***"
	echo "You should log in as root to run this script."
	echo "Some system information will not be checked"
	echo ""

	waitForReturn 1

fi

# Assemble the components of the complete script name

DEFAULT_PATH=`dirname $0`

if [ "$DEFAULT_PATH" = "" ]
then
    # dirname doesn't work. use 'which'
    DEFAULT_PATH=`which $0 | tail -1 |sed -e 's/\(.*\)\/$0/\1/'`
fi

DEFAULT_FILENAME=sys_reqs.txt

DEFAULT_FILE=$DEFAULT_PATH/$DEFAULT_FILENAME

TMP_FILE=/tmp/qt.out

INTERACTIVE=1
VERBOSE=0
FRAME_BUFFER_ONLY=0
VALID=1
EMAIL=0
EMAIL_LIST=""

clear

for param in $*
do
    case $param in
    -h) printUsageAndExit
	;;
    -v) VERBOSE=1
	shift 1
	;;
    -c) DEFAULT_FILE=$2
	shift 2
	;;
    -n) INTERACTIVE=0
	shift 1
	;;
    -f) FRAME_BUFFER_ONLY=1
	shift 1
	;;
    -t) TMP_FILE=$2
	shift 2
	;;
    -e) shift 1
	EMAIL_LIST=$*
	EMAIL=1
	;;
    -*) printUsageAndExit
	;;
    esac
done


if [ -d $TMP_FILE ]
then
    VALID=0
    echo "ERROR: The temporary output file you specified is a directory, not a file."
    echo ""

fi

if [ -d $DEFAULT_FILE ]
then
    DEFAULT_FILE=`echo $DEFAULT_FILE | sed -e 's/\(.*\)\/$/\1/'`
    DEFAULT_FILE=$DEFAULT_FILE/$DEFAULT_FILENAME
fi

if [ ! -f $DEFAULT_FILE ]
then
    VALID=0

    if [ "$DEFAULT_FILE" = "$DEFAULT_PATH/$DEFAULT_FILENAME" ]
    then
	echo "ERROR: The system requirements file, $DEFAULT_FILE does not exist."
	echo "       Specify the location with the -c option."
	echo ""
    else
	echo "ERROR: The system requirements file, $DEFAULT_FILE"
	echo "       that you specified with the -c option does not exist."
	echo "       Please double check the location."
	echo ""
    fi

fi

if [ -f $TMP_FILE ]
then
    VALID=0

    echo "ERROR: The temporary output file, $TMP_FILE"
    echo "       exists. Please specify a different temporary output"
    echo "       file with the -t option or delete the file."
    echo ""
else

    if [ $VALID -eq 1 ]
    then

	touch $TMP_FILE
	
	    if [ ! -w $TMP_FILE ]
	    then

		VALID=0
		echo "ERROR: The script cannot write to the specified"
		echo "       temporary output file, $TMP_FILE"
		echo "       Please specify a different temporary output file"
		echo "       with the -t option."
		echo ""
	    fi
    fi
fi


if [ $VALID -eq 0 ]
then
    printUsageAndExit
fi


#################################################################
#
# Variables specified on command line are valid, continue
#
#################################################################

drawBanner $TMP_FILE
printPurpose

waitForReturn $INTERACTIVE


#################################################################
#
# Determine the OS support, then
# display the system type and os version
#
#################################################################

echo "----------------------------------------------------" | tee -a $TMP_FILE
echo "|                  System Report                   |" | tee -a $TMP_FILE
echo "----------------------------------------------------" | tee -a $TMP_FILE
echo ""                                                     | tee -a $TMP_FILE

systype_os_string=`uname -rs`
systype=`uname -s`

if [ $systype = "Linux" ]
then
	if [ -f /etc/issue ] 
	then
		linux_dist=`cat /etc/issue | grep release`
	else
		linux_dist="Unknown"
	fi

	linux_kernel=`uname -r`

	# SPR274646
	# Might need to add more constraints if /etc/issue format changes for other distribution.
	# added the following to the check:
	# '2d'     - remove 2nd line
	# '/^$/d'  - clears off empty line in /etc/issue
	os_version=`cat /etc/issue | sed -e '2d' -e '/^$/d' -e 's/Welcome to //g' -e 's/ (.*//g'`

	case $os_version in
	"SUSE LINUX Enterprise Server 9")
		os_version=SLES9
	;;
	"Red Hat Enterprise Linux WS release 3")
		os_version=RH3.0WS
	;;
	"Red Hat Enterprise Linux WS release 4")
		os_version=RH4.0WS
	;;
	"CentOS release 4"*)	#all version of CentOS or must be be 4.6?
		os_version=CENT4
	;;
	*) #all other that is not captured or officially supported by quartus
		os_version=`uname -r`
	;;
	esac

	check_os=`grep "^system $systype" $DEFAULT_FILE`
   	if [ "$check_os" != "" ]
   	then
   		check_os=`grep "$systype $os_version" $DEFAULT_FILE`
   	fi

else
	os_version=`uname -r`
	check_os=`grep "^system $systype_os_string" $DEFAULT_FILE`
fi

software_version=`grep "^version" $DEFAULT_FILE | cut -f 2- -d ' '`
hostname=`hostname`

echo "Target Software:     $software_version" | tee -a $TMP_FILE
echo "       Hostname:     $hostname"         | tee -a $TMP_FILE
echo "    System type:     $systype"          | tee -a $TMP_FILE
if [ $systype = "Linux" ]
then
echo "     Linux dist:     $linux_dist"       | tee -a $TMP_FILE
echo "     kernel rev:     $linux_kernel"     | tee -a $TMP_FILE
fi
echo "     OS Version:     $os_version"       | tee -a $TMP_FILE

if [ "$check_os" = "" ]
  then
    if [ $systype != "Linux" ]
    then
      check_systype=`grep "^system $systype" $DEFAULT_FILE`

      if [ "$check_systype" != "" ]
      then
	  echo ""
	  echo "ERROR: $systype is supported but the"
	  echo "       operating system version reported ($os_version)"
	  echo "       must be in this list:"
	  echo ""

	  for os in `grep "^system $systype" $DEFAULT_FILE | cut -f 3 -d ' ' | sort | uniq`
	  do
	      echo "       $os"
	  done
	  
      else
	  echo ""
	  echo "ERROR: $systype is not a supported"
	  echo "       system type. The system type that"
	  echo "       uname -s reports ($systype)"
	  echo "       must be in this list:"
	  echo ""

	  for type in `grep "^system" $DEFAULT_FILE | cut -f 2 -d ' ' | sort | uniq`
	  do
	      echo "       $type"
	  done
      fi
 
    echo ""

    rm -f $TMP_FILE
    exit 0
  else
    echo "WARNING: $os_version is not in the list"
    echo "         of approved Linux distributions or versions."
    echo ""
  fi
fi


if [ $VERBOSE -eq 1 ]
then 

    echo ""

    waitForReturn $INTERACTIVE

#################################################################
#
# If verbose switch is specified,
# display the extended system information, based on the OS
#
#################################################################

    echo "----------------------------------------------------" | tee -a $TMP_FILE
    echo "|          Extended System Information             |" | tee -a $TMP_FILE
    echo "----------------------------------------------------" | tee -a $TMP_FILE
    echo ""                                                     | tee -a $TMP_FILE

    case $systype in
	SunOS)
	    modelname=`/usr/sbin/prtconf | grep '^SUNW' |cut -f 2 -d ','`
	    echo "Model name: $modelname"  | tee -a $TMP_FILE
	    /usr/bin/showrev               | tee -a $TMP_FILE
	    /usr/sbin/sysdef               | tee -a $TMP_FILE
	    ;;

	HP-UX)
		echo "System Parameters ..."
		cat /usr/conf/master.d/core-hpux | egrep -v '^\*'
		echo "Kernel information ..."
		what /stand/vmunix
	    ;;

	Linux)
        cat /etc/issue                 | tee -a $TMP_FILE
		echo "System Parameters..."
	    /sbin/sysctl -A                | tee -a $TMP_FILE
		;;
    esac

	/usr/bin/env  | tee -a $TMP_FILE

else

    echo "" >> $TMP_FILE
    echo "----------------------------------------------------" >> $TMP_FILE
    echo "|          Extended System Information             |" >> $TMP_FILE
    echo "----------------------------------------------------" >> $TMP_FILE
    echo ""                                                     >> $TMP_FILE

    case $systype in
	SunOS)
	    modelname=`/usr/sbin/prtconf | grep '^SUNW' |cut -f 2 -d ','`
	    echo "Model name: $modelname"  >> $TMP_FILE
	    /usr/bin/showrev               >> $TMP_FILE
	    /usr/sbin/sysdef               >> $TMP_FILE

	    ;;
	HP-UX)
	    ;;

	Linux)
        cat /etc/issue >> $TMP_FILE
	    /sbin/sysctl -A >> $TMP_FILE
		;;
    esac

    echo "" >> $TMP_FILE
	/usr/bin/env  >> $TMP_FILE
    echo "" >> $TMP_FILE

fi


if [ $VERBOSE -eq 1 ]
then

    echo ""

    waitForReturn $INTERACTIVE

#################################################################
#
# If verbose switch is specified,
# display the processor banner and information, based on the OS
#
#################################################################

    echo "----------------------------------------------------" | tee -a $TMP_FILE
    echo "|             Processor Information                |" | tee -a $TMP_FILE
    echo "----------------------------------------------------" | tee -a $TMP_FILE
    echo ""                                                     | tee -a $TMP_FILE
    
    case $systype in
	SunOS)
	    /usr/sbin/psrinfo -v | tee -a $TMP_FILE
	    ;;
	Linux)
	    cputype=`cat /proc/cpuinfo | grep 'model name' | awk '{ for (i=4; i<=NF; i++) { printf "%s ",$i; }; }'`
            cpuspeed=`cat /proc/cpuinfo | grep 'cpu MHz' | awk '{print $4; }'`
	    echo "CPU type:  $cputype" | tee -a $TMP_FILE
            echo "CPU speed: $cpuspeed MHz" | tee -a $TMP_FILE
            ;;
    esac

else

    echo "----------------------------------------------------" >> $TMP_FILE
    echo "|             Processor Information                |" >> $TMP_FILE
    echo "----------------------------------------------------" >> $TMP_FILE
    echo ""                                                     >> $TMP_FILE
    
    case $systype in
	SunOS)
	    /usr/sbin/psrinfo -v >> $TMP_FILE
	    ;;
	Linux)
	    cputype=`cat /proc/cpuinfo | grep 'model name' | awk '{ for (i=4; i<=NF; i++) { printf "%s ",$i; }; }'`
            cpuspeed=`cat /proc/cpuinfo | grep 'cpu MHz' | awk '{print $4; }'`
	    echo "CPU type:  $cputype" >> $TMP_FILE
            echo "CPU speed: $cpuspeed MHz" >> $TMP_FILE
            ;;
    esac

    echo "" >> $TMP_FILE

fi


if [ $VERBOSE -eq 1 ]
then

    echo ""
    waitForReturn $INTERACTIVE

#################################################################
#
# If verbose switch is specified,
# display the memory information banner
#
#################################################################

    echo "----------------------------------------------------" | tee -a $TMP_FILE
    echo "|                Memory Information                |" | tee -a $TMP_FILE
    echo "----------------------------------------------------" | tee -a $TMP_FILE
    echo ""                                                     | tee -a $TMP_FILE

else 

    echo "----------------------------------------------------" >> $TMP_FILE
    echo "|                Memory Information                |" >> $TMP_FILE
    echo "----------------------------------------------------" >> $TMP_FILE
    echo ""                                                     >> $TMP_FILE

fi

physical_mem=0

case $systype in
    SunOS)
	physical_mem=`/usr/sbin/prtconf | grep Memory | cut -f 3 -d ' '`
	echo "Physical memory:     $physical_mem Megabytes"     | tee -a $TMP_FILE

	;;
    HP-UX)

	if [ $NOT_ROOT -eq 1 ]
	then

		echo "Physical memory:     NOT CHECKED"         | tee -a $TMP_FILE
	else

		physical_mem=`/usr/sbin/dmesg |grep available | awk '{print $2}'`
		physical_mem=`expr $physical_mem / 1024`
		echo "Physical memory:     $physical_mem Megabytes"| tee -a $TMP_FILE

	fi
	;;
    Linux)
        physical_mem=`cat /proc/meminfo | grep "^MemTotal" | awk '{ printf "%d",($2+1023)/1024; }'`
	echo "Physical memory:     $physical_mem Megabytes" | tee -a $TMP_FILE
    ;;
esac

echo "" | tee -a $TMP_FILE

#echo "Physical memory:     $physical_mem Megabytes"             | tee -a $TMP_FILE


if [ $VERBOSE -eq 1 ]
then

    echo ""

    waitForReturn $INTERACTIVE

#################################################################
#
# If verbose switch is specified,
# display the swap information banner
#
#################################################################

    echo "----------------------------------------------------" | tee -a $TMP_FILE
    echo "|                 Swap Information                 |" | tee -a $TMP_FILE
    echo "----------------------------------------------------" | tee -a $TMP_FILE
    echo ""                                                     | tee -a $TMP_FILE

else
    echo "" >> $TMP_FILE
    echo "----------------------------------------------------" >> $TMP_FILE
    echo "|                 Swap Information                 |" >> $TMP_FILE
    echo "----------------------------------------------------" >> $TMP_FILE
    echo ""                                                     >> $TMP_FILE


fi

physical_mem=0

case $systype in
    SunOS)

	/usr/sbin/swap -l | grep -v '^swapfile' | \
	nawk 'BEGIN { alloc=0; free=0; \
	printf "Device or mount point    Size    Free\n";\
	printf "                       (Megs)  (Megs)\n"; \
	printf "-------------------------------------\n";} /^\// \
	{ alloc=alloc + $4; free=free + $5; \
	printf "%21s%8d%8d\n", $1, $4/1024, $5/1024; } \
	END { printf "-------------------------------------\n"; \
	printf "%21s%8d%8d\n", "Total", alloc/1024, free/1024; }' >> $TMP_FILE

	if [ $VERBOSE -eq 1 ]
	then
	    /usr/sbin/swap -l | grep -v '^swapfile' | \
	    nawk 'BEGIN { alloc=0; free=0; \
	    printf "Device or mount point    Size    Free\n";\
	    printf "                       (Megs)  (Megs)\n"; \
	    printf "-------------------------------------\n";} /^\// \
	    { alloc=alloc + $4; free=free + $5; \
	    printf "%21s%8d%8d\n", $1, $4/1024, $5/1024; } \
	    END { printf "-------------------------------------\n"; \
	    printf "%21s%8d%8d\n", "Total", alloc/1024, free/1024; }'

	else
	    /usr/sbin/swap -l |grep -v '^swapfile' | \
	    nawk 'BEGIN { alloc=0; free=0; } /^\// \
	    { alloc=alloc + $4; free=free + $5; } END \
	    { printf " Allocated swap: %8d Megabytes\n", alloc/1024;
	    printf "      Free swap: %8d Megabytes\n", free/1024}'
	
	fi
    ;;
    HP-UX)

	if [ $NOT_ROOT -eq 1 ]
	then

		echo " Allocated swap:     NOT CHECKED"     | tee -a $TMP_FILE
		echo "      Free swap:     NOT CHECKED"     | tee -a $TMP_FILE

	else

	/usr/sbin/swapinfo -m |grep '^dev' | \
	awk 'BEGIN {alloc=0; free=0; \
	printf "Device or mount point     Size     Free\n"; \
	printf "                        (Megs)   (Megs)\n"; \
	printf "---------------------------------------\n";} /^dev/ \
	{ alloc=alloc + $2; free=free + $4; \
	printf "%21s%8d%8d\n", $9, $2, $4; } \
	END { printf "---------------------------------------\n"; \
	printf "%21s%8d%8d\n", "Total", alloc, free;}' >> $TMP_FILE


	if [ $VERBOSE -eq 1 ]
	then

		/usr/sbin/swapinfo -m |grep '^dev' | \
		awk 'BEGIN {alloc=0; free=0; \
		printf "Device or mount point     Size     Free\n"; \
		printf "                        (Megs)   (Megs)\n"; \
		printf "---------------------------------------\n";} /^dev/ \
		{ alloc=alloc + $2; free=free + $4; \
		printf "%21s%8d%8d\n", $9, $2, $4; } \
		END { printf "---------------------------------------\n"; \
		printf "%21s%8d%8d\n", "Total", alloc, free;}'
	else

		/usr/sbin/swapinfo -m |grep '^dev' | \
		awk 'BEGIN {alloc=0; free=0; } /^dev/ \
		{ alloc=alloc + $2; free=free + $4; } END \
		{ printf " Allocated swap: %8d Megabytes\n", alloc;
		printf "      Free swap: %8d Megabytes\n", free}'

	fi

	fi
    ;;
    Linux)

    	/sbin/swapon -s | grep '^/dev' | \
	awk 'BEGIN {\
               alloc=0; \
               used=0; \
	       printf "Device or mount point    Size    Used\n"; \
	       printf "                         (Mb)    (Mb)\n"; \
	       printf "---------------------------------------\n"; \
             } \
             /^\/dev/ { \
               tmp_alloc = (($3 + 1023)/1024); \
               tmp_used  = (($4 + 1023)/1024);\
               alloc = alloc + $3; \
               used  = used + $4; \
	       printf "%21s%8d%8d\n", $1, tmp_alloc, tmp_used; } \
	     END { \
               printf "---------------------------------------\n"; \
	       printf "%21s%8d%8d\n", "Total", ((alloc+1023)/1024), ((used+1023)/1024); \
            }' | tee -a $TMP_FILE
    ;;
esac

echo ""  | tee -a $TMP_FILE

waitForReturn $INTERACTIVE


#################################################################
#
# Display the patch banner and information
#
#################################################################

echo "----------------------------------------------------" | tee -a $TMP_FILE
echo "|                 Patch Information                |" | tee -a $TMP_FILE
echo "----------------------------------------------------" | tee -a $TMP_FILE
echo ""                                                     | tee -a $TMP_FILE

case $systype in

SunOS)

nawk -v SYSTYPE=$systype -v OS_VERSION=$os_version 'BEGIN { \
    required_patches = 0; recommended_patches = 0; hardware_patches = 0; \
    printed_rec = 0; printed_hard = 0; } \

    { \
	if ( ( $1 == SYSTYPE ) && ( $3 == OS_VERSION ) ) { \

	    installed = 0; \

	    # Patch is required \
	    if (( $2 == 3 ) || ( $2 == 2 )) { \

		print "      $4:     "; \
		for ( i = 4; i <= NF; ++i) { \

		    installed = 0; \
		    if (system("showrev -a | cut -f2 -d \" \" | grep " $i " 1>/dev/null 2>&1") == 0) { \
		    
			installed = 1; \
			if ( i == 4 ) { print "installed.\n"; break; } \
			else { \
			    print "satisfied by "; \
			    system("showrev -a |cut -f2 -d \" \" | grep " $i "| sort | tail -1  2>/dev/null"); \
			    break; \
			} \
		    } \
		} \

		if ( installed == 0 ) { \
		    required_patches = 1; \
		    print "not installed and is required.\n"; \
		} \
	    } \

	    installed = 0; \

	    # Patch is device specific \
	    if ( $2 == 0 ) { \

		if ( printed_hard == 0 ) { \

		    printf "\n    Checking patches for a display terminal...\n"; \
		    printed_hard = 1; \
		} \

		if (system("ls " $NF " 2>/dev/null |grep " $NF " 1>/dev/null 2>&1") == 0) { \

		    printf "      " $4 ":     "; \
		    for ( i = 4; i <= NF-1; ++i) { \


			installed = 0; \
			if (system("showrev -a | grep " $i " 1>/dev/null 2>&1") == 0) { \
		    
			    installed = 1; \
			    if ( i == 4 ) { printf "installed.\n"; break; } \
			    else { \
				printf "satisfied by "; \
				system("showrev -a |cut -f2 -d \" \" | grep " $i "| sort | tail -1  2>/dev/null"); \
				break; \
			    } \
			} \
		    } \

		    if ( installed == 0 ) { \
			hardware_patches = 1; \
			printf "not installed and is required.\n"; \
		    } \
		} \
	    } \

	}\
    } \
    END { \

	if ( ( required_patches + recommended_patches + hardware_patches ) > 0 ) { \
	    printf "\nThis script detected some missing or out of date patches, as listed above.\n"; \
	    printf "Install these patches prior to running Altera software.\n"; \
	} else { \
	    printf "\nThe patches on this system are up to date.\n"; \
	} \

	printf "\n";\

    }' $DEFAULT_FILE | tee -a $TMP_FILE

;;
HP-UX)

awk -v SYSTYPE=$systype -v OS_VERSION=$os_version 'BEGIN { \
    required_patches = 0; recommended_patches = 0; hardware_patches = 0; \
    printed_rec = 0; printed_hard = 0; } \

    { \
	if ( ( $1 == SYSTYPE ) && ( $3 == OS_VERSION ) ) { \

	    installed = 0; \

	    # Patch is required \
	    if ( $2 == 0 ) { \

		printf "%5s%10s:%5s", "     ",$4, "     "; \
		for ( i = 4; i <= NF; ++i) { \

		    installed = 0; \
		    if (system("/usr/sbin/swlist -v | grep " $i "  1>/dev/null 2>&1") == 0) { \
		    
			installed = 1; \
			if ( i == 4 ) { printf "installed.\n"; break; } \
			else { \
			    printf "satisfied by %10s\n", $i; \
			    break; \
			} \
		    } \
		} \

		if ( installed == 0 ) { \
		    required_patches = 1; \
		    printf "not installed and is required.\n"; \
		} \
	    } \
	}\
    } \
    END { \

	if ( ( required_patches + recommended_patches + hardware_patches ) > 0 ) { \
	    printf "\nThis script detected some missing or out of date patches, as listed above.\n"; \
	    printf "Install these patches prior to running Altera software.\n"; \
	} else { \
	    printf "\nThe patches on this system are up to date.\n"; \
	} \

	printf "\n";\

    }' $DEFAULT_FILE | tee -a $TMP_FILE


;;

Linux)

awk -v SYSTYPE=$systype -v OS_VERSION=$os_version 'BEGIN { \
	    printf "\nThe patches on this system are up to date.\n"; \
    }' $DEFAULT_FILE | tee -a $TMP_FILE

;;

esac


if [ $EMAIL -eq 1 ]
then

    echo ""
    waitForReturn $INTERACTIVE


    echo "----------------------------------------------------"
    echo "|                  Email Reports                   |"
    echo "----------------------------------------------------"
    echo ""

    echo "" >> $TMP_FILE
    echo "This information has been sent to the following list of people" >> $TMP_FILE
    echo "$EMAIL_LIST" >> $TMP_FILE
    
    for address in $EMAIL_LIST
    do
	echo "     Mailing results to $address"
	mail -s "QT Results for $hostname" $address < $TMP_FILE
	
    done
fi

rm -f $TMP_FILE

#################################################################
#
# Exit the script
#
#################################################################

exit 0;


