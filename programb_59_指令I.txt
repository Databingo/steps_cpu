//// rv32i + rv64i extension = 47 + 15 - 3 重复(SLLI SRLI SRAI) = 62 - 3 = 59 条指令
//// -------------re-order-by-operation_code-----------
//// load 加载(内存到寄存器) 7
//00000000 00000000 00000000 00000011 //___000000000000_00000_000_00000_0000011 //#LB   |imm.12|rs1.5|000.3|rd.5|0000011.7|    load 8 bite sign extend to 64 bits at imm(s1) to rd       
//00000000 00000000 01000000 00000011 //___000000000000_00000_100_00000_0000011 //#LBU  |imm.12|rs1.5|100.3|rd.5|0000011.7|    load 8 bite unsign to 64 bits at imm(s1) to rd         
//00000000 00000000 00010000 00000011 //___000000000000_00000_001_00000_0000011 //#LH   |imm.12|rs1.5|001.3|rd.5|0000011.7|    load half-word 16     
//00000000 00000000 01010000 00000011 //___000000000000_00000_101_00000_0000011 //#LHU  |imm.12|rs1.5|101.3|rd.5|0000011.7|    load half-word 16 unsigned 
//00000000 00000000 00100000 00000011 //___000000000000_00000_010_00000_0000011 //#LW   |imm.12|rs1.5|010.3|rd.5|0000011.7|    load word 32          
//00000000 00000000 01100000 00000011 //___000000000000_00000_110_00000_0000011 //#LWU  |imm.12|rs1.5|110.3|rd.5|0000011.7| 64 load word 32 unsigned  
//00000000 00000000 00110000 00000011 //___000000000000_00000_011_00000_0000011 //#LD   |imm.12|rs1.5|011.3|rd.5|0000011.7| 64 load double-word 64 // op rd, imm(rs1)|label: op rd, imm(rs1)   
//// Store 存储(寄存器到内存) 4
//00000000 00000000 00000000 00100011 //___000000000000_00000_000_00000_0100011 //#SB   |imm.7|rs2.5|rs1.5|000.3|imm.5|0100011.7|    store byte, write low 8 bits of rs2 to rs1's imm.12
//00000000 00000000 00010000 00100011 //___000000000000_00000_001_00000_0100011 //#SH   |imm.7|rs2.5|rs1.5|001.3|imm.5|0100011.7|    store half-word, write low 16 bits of rs2 to rs1's imm.12
//00000000 00000000 00100000 00100011 //___000000000000_00000_010_00000_0100011 //#SW   |imm.7|rs2.5|rs1.5|010.3|imm.5|0100011.7|    store word, 32
//00000000 00000000 00110000 00100011 //___000000000000_00000_011_00000_0100011 //#SD   |imm.7|rs2.5|rs1.5|011.3|imm.5|0100011.7| 64 store double-word, 64 // op rs2, imm(rs1)|label: op rs2, imm(rs1)
//// Upper 上立即数 2
//00000000 00000000 00000000 00110111 //_____00000000000000000000_00000_0110111 //#LUI  |imm.20|rd.5|0110111.7| put 20 bits immediate to upper 20 bits of rd[31:12] sext to 64 and left lower 12 bits 0
//00000000 00000000 00000000 00010111 //_____00000000000000000000_00000_0010111 //*AUIPC|imm.20|rd.5|0010111.7| left shift the 20 bits immediate 12 bits then add pc value then put to rd // op rd, imm
//// 算数逻辑位移 立即数类型 Math-Logic-I 9  (LUI need plus 1 when ADDI nege imm)  
//00000000 00000000 00000000 00010011 //___000000000000_00000_000_00000_0010011 //*ADDI |imm.12|rs1.5|000.3|rd.5|0010011.7| sign-extend imm.12 to 64 add sr1.64 overflow ingnored to rd|op rd,rs1,imm 
//00000000 00000000 00000000 00011011 //___000000000000_00000_000_00000_0011011 //*ADDIW|imm.12|rs1.5|000.3|rd.5|0011011.7| sign-extend imm.12 to 32 add to sr1.low32 then sign-extend sum.32 to rd.64
//00000000 00000000 00100000 00010011 //___000000000000_00000_010_00000_0010011 //*SLTI |imm.12|rs1.5|010.3|rd.5|0010011.7| if rs1 is less than imm.12 both as sign-extended then put 1 in rd else 0
//00000000 00000000 00110000 00010011 //___000000000000_00000_011_00000_0010011 //*SLTIU|imm.12|rs1.5|011.3|rd.5|0010011.7| if rs1 is less than imm.12 both as unsigned number then put 1 in rd else 0
//00000000 00000000 01100000 00010011 //___000000000000_00000_110_00000_0010011 //*ORI  |imm.12|rs1.5|110.3|rd.5|0010011.7| bitwise OR  rs1 and sign-extend imm.12 put reslut in rd
//00000000 00000000 01110000 00010011 //___000000000000_00000_111_00000_0010011 //*ANDI |imm.12|rs1.5|111.3|rd.5|0010011.7| bitwise AND rs1 and sign-extend imm.12 put reslut in rd
//00000000 00000000 01000000 00010011 //___000000000000_00000_100_00000_0010011 //*XORI |imm.12|rs1.5|100.3|rd.5|0010011.7| XOR (XORI, rd, rs1, -1) same as (NOT, rd, rs)
////00000000 00000000 00010000 00010011 //__0000000_00000_00000_001_00000_0010011 // SLLI |imm.12|rs1.5|001.3|rd.5|0010011.7|  shift lift  logicl rs1 32 by imm.12[low5.unsign] padding 0 put into rd 
////00000000 00000000 01010000 00010011 //__0000000_00000_00000_101_00000_0010011 // SRLI |imm.12|rs1.5|101.3|rd.5|0010011.7|  shift right logicl rs1 32 by imm.12[low5.unsign] padding 0 put into rd
////01000000 00000000 01010000 00010011 //__0100000_00000_00000_101_00000_0010011 // SRAI |imm.12|rs1.5|101.3|rd.5|0010011.7|  shift right arithmetical logicl rs1 32 by imm.12[low5.unsign] padding 1to rd
//// 算数逻辑位移 立即数类型 64 位 Math-Logic-I-64 7
//00000000 00000000 00010000 00010011 //__000000_000000_00000_001_00000_0010011 //*SLLI   |000000.6|shamt.6|rs1.5|001.3|rd.5|0010011.7| 64 shift lift  logicl rs1 64 by imm.12[low6.unsign] padding 0 to rd
//00000000 00000000 01010000 00010011 //__000000_000000_00000_101_00000_0010011 //*SRLI   |000000.6|shamt.6|rs1.5|101.3|rd.5|0010011.7| 64 shift right rs1 shamt.6[unsign] padding 0 to rd, srli rd,rs1,amt
//01000000 00000000 01010000 00010011 //__010000_000000_00000_101_00000_0010011 //*SRAI   |010000.6|shamt.6|rs1.5|101.3|rd.5|0010011.7| 64 shift right arithm rs1 shamt.6[unsign] padding sign to rd
//00000000 00000000 00010000 00011011 //__0000000_00000_00000_001_00000_0011011 //*SLLIW  |imm.12|rs1.5|001.3|rd.5|0011011.7| 64 shift lift  logicl rs1 32 by imm.12[low5.unsign].shamt padding 0 to rd 
//00000000 00000000 01010000 00011011 //__0000000_00000_00000_101_00000_0011011 //*SRLIW  |imm.12|rs1.5|101.3|rd.5|0011011.7| 64 shift right logicl rs1 32 by imm.12[low5.unsign].shamt padding 0 to rd 
//01000000 00000000 01010000 00011011 //__0100000_00000_00000_101_00000_0011011 //*SRAIW  |imm.12|rs1.5|101.3|rd.5|0011011.7| 64 shift right arithm logicl rs1 32 by imm.12[L5.unsign] padding 1 to rd
//// 算数逻辑位移 寄存器类型 Math-Logic-R 10
//00000000 00000000 00000000 00110011 //__0000000_00000_00000_000_00000_0110011 //*ADD  |xxx.7|rs2.5|rs1.5|000.3|rd.5|0110011.7| add rs1 and rs2 send overflow ingnored result to rd 
//01000000 00000000 00000000 00110011 //__0100000_00000_00000_000_00000_0110011 //*SUB  |xxx.7|rs2.5|rs1.5|000.3|rd.5|0110011.7| sub rs2 from rs1 send overflow ingnored result to rd |sub rd rs1 rs2
//00000000 00000000 00100000 00110011 //__0000000_00000_00000_010_00000_0110011 //*SLT  |xxx.7|rs2.5|rs1.5|010.3|rd.5|0110011.7| if rs1 is less than rs2 both as sign-extended then Set 1 in rd else 0
//00000000 00000000 00110000 00110011 //__0000000_00000_00000_011_00000_0110011 //*SLTU |xxx.7|rs2.5|rs1.5|011.3|rd.5|0110011.7| if rs1 is less than rs2 both as unsigned number then Set 1 in rd else 0
//00000000 00000000 01100000 00110011 //__0000000_00000_00000_110_00000_0110011 //*OR   |xxx.7|rs2.5|rs1.5|110.3|rd.5|0110011.7| bitwise OR  rs1 and rs2 then put reslut in rd
//00000000 00000000 00000000 00110011 //__0000000_00000_00000_000_00000_0110011 //*AND  |xxx.7|rs2.5|rs1.5|000.3|rd.5|0110011.7| bitwise AND rs1 and rs2 then put result in rd
//00000000 00000000 01000000 00110011 //__0000000_00000_00000_100_00000_0110011 //*XOR  |xxx.7|rs2.5|rs1.5|100.3|rd.5|0110011.7| bitwise XOR rs1 and rs2 then put reslut in rd
//00000000 00000000 00010000 00110011 //__0000000_00000_00000_001_00000_0110011 //*SLL  |xxx.7|rs2.5|rs1.5|001.3|rd.5|0110011.7| shift lift  logicl rs1 by rs2[low5.unsign] padding 0 then put into rd 
//00000000 00000000 01010000 00110011 //__0000000_00000_00000_101_00000_0110011 //*SRL  |xxx.7|rs2.5|rs1.5|101.3|rd.5|0110011.7| shift right logicl rs1 by amount in rs2[low5.unsign] padding 0 put into rd
//01000000 00000000 01010000 00110011 //__0100000_00000_00000_101_00000_0110011 //*SRA  |xxx.7|rs2.5|rs1.5|101.3|rd.5|0110011.7| shift right arithmetical logicl rs1 rs2[low5.unsign] padding 1 put into rd //// 算数逻辑位移 寄存器类型 64 位 Math-Logic-R-64 5
//00000000 00000000 00000000 00111011 //__0000000_00000_00000_000_00000_0111011 //*ADDW   |xxx.7|rs2.5|rs1.5|000.3|rd.5|0111011.7| 64 add rs1 32 and rs2 32 as overflow-ingnored low 32 sext 64 to rd 
//01000000 00000000 00000000 00111011 //__0100000_00000_00000_000_00000_0111011 //*SUBW   |xxx.7|rs2.5|rs1.5|000.3|rd.5|0111011.7| 64 sub rs2 32 from rs1 32 as overflow-ingnored low 32 sext 64 to rd
//00000000 00000000 00010000 00111011 //__0000000_00000_00000_001_00000_0111011 //*SLLW   |xxx.7|rs2.5|rs1.5|001.3|rd.5|0111011.7| 64 shift lift  logicl rs1 low 32 by rs2[l5unsign] padding 0 to rd 32
//00000000 00000000 01010000 00111011 //__0000000_00000_00000_101_00000_0111011 //*SRLW   |xxx.7|rs2.5|rs1.5|101.3|rd.5|0111011.7| 64 shift right logicl rs1 low 32 by rs2[l5unsign] padding 0 to rd 32 
//01000000 00000000 01010000 00111011 //__0100000_00000_00000_101_00000_0111011 //*SRAW   |xxx.7|rs2.5|rs1.5|101.3|rd.5|0111011.7| 64 shift right arithm logicl rs1 32 by rs2[L5unsign] padding 1 to rd 
//// Branch 分支 6
//00000000 00000000 00000000 01100011 //0_000000_00000_00000_000_0000_0_1100011 //*BEQ    |imm.7[12|10:5]|rs2.5|rs1.5|000.3|imm.5[4:1|11]|1100011.7| take branch if rs1 rs2 equal to PC+(sign-extend imm_0)
//00000000 00000000 00010000 01100011 //0_000000_00000_00000_001_0000_0_1100011 //*BNE    |imm.7[12|10:5]|rs2.5|rs1.5|001.3|imm.5[4:1|11]|1100011.7| take branch if rs1 and rs2 not equal
//00000000 00000000 01000000 01100011 //0_000000_00000_00000_100_0000_0_1100011 //*BLT    |imm.7[12|10:5]|rs2.5|rs1.5|100.3|imm.5[4:1|11]|1100011.7| take branch if rs1 less than rs2 in signed comparison 
//00000000 00000000 01010000 01100011 //0_000000_00000_00000_101_0000_0_1100011 //*BGE    |imm.7[12|10:5]|rs2.5|rs1.5|101.3|imm.5[4:1|11]|1100011.7| take branch if rs1 >= rs2 in signed comparison 
//00000000 00000000 01100000 01100011 //0_000000_00000_00000_110_0000_0_1100011 //*BLTU   |imm.7[12|10:5]|rs2.5|rs1.5|100.3|imm.5[4:1|11]|1100011.7| take branch if rs1 < rs2 in unsigned comparison 
//00000000 00000000 01110000 01100011 //0_000000_00000_00000_111_0000_0_1100011 //*BGEU   |imm.7[12|10:5]|rs2.5|rs1.5|111.3|imm.5[4:1|11]|1100011.7| take branch if rs1 >= rs2 in unsigned comparison 
//// Ijump PC跳转 PC+立即数 1 (都有立即数)
//00000000 00000000 00000000 01101111 //__0_0000000000_0_00000000_00000_1101111 //*JAL    |imm.21[20|10:1|11|19:12]|rd.5|1101111.7|jump PC to PC+imm(20 padding 0),put return address PC+4 in rd:jal rd imm
//// Rjump 寄存器跳转 寄存器+立即数 1 (都有立即数)
//00000000 00000000 00000000 01100111 //___000000000000_00000_000_00000_1100111 //*JALR   |imm.12|rs1.5|000|rd.5|1100111.7| jump PC to address imm(rs1) and place return address PC+4 in rd:jalr rd,rs1,imm 
//// Control 控制 10
//00000000 00000000 00000000 00001111 //_0000_0000_0000_00000_000_00000_0001111 // FENCE  |0.4|pred.4|succ.4|0.5|000.3|0.5|0001111.7| sure RW I/O and memory completed before FENCE for successor
//00000000 00000000 00010000 00001111 //_0000_0000_0000_00000_001_00000_0001111 // FENCE.I|0.4|0000.4|0000.4|0.5|001.3|0.5|0001111.7| sure instruction operation completed before FENCE.I
//00000000 00000000 00000000 01110011 //___000000000000_00000_000_00000_1110011 // ECALL  |0.12|0.4|000.3|0.5|1110011.7| system enviroment call, put break in pc and save pc to rg
//00000000 00010000 00000000 01110011 //___000000000001_00000_000_00000_1110011 // EBREAK |k.12|0.4|000.3|0.5|1110011.7| system break call, put break in pc and save pc to rg
//00000000 00000000 00010000 01110011 //___000000000000_00000_001_00000_1110011 // CSRRW  |csr.12|rs1.5|001.3|rd.5|1110011.7| atomic write, put 0-extend csr in rd, then put sr1 to csr//csrrw rd,csr,rs1
//00000000 00000000 00100000 01110011 //___000000000000_00000_010_00000_1110011 // CSRRS  |csr.12|rs1.5|001.3|rd.5|1110011.7| atomic set, put 0-extend csr in rd, sr1 as 1 mask set csr 1 correspond
//00000000 00000000 00110000 01110011 //___000000000000_00000_011_00000_1110011 // CSRRC  |csr.12|rs1.5|011.3|rd.5|1110011.7| atomic clear, put 0-extend csr in rd, sr1 as 1 mask set csr 0 under
//00000000 00000000 01010000 01110011 //___000000000000_00000_101_00000_1110011 // CSRRWI |csr.12|zim.5|101.3|rd.5|1110011.7| atomic write, put 0-extend csr in rd, 0-extend 5unsigned zimm to csr 
//00000000 00000000 01100000 01110011 //___000000000000_00000_110_00000_1110011 // CSRRSI |csr.12|zim.5|110.3|rd.5|1110011.7| atomic set, 0-extend csr in rd, 0-extended 5unsigned zimm as 1 mask set csr 1
//00000000 00000000 01110000 01110011 //___000000000000_00000_111_00000_1110011 // CSRRCI |csr.12|zim.5|111.3|rd.5|1110011.7| atomic clear,0-extend csr in rd, 0-extended 5unsigned zimm as 1 mask set csr0

//测试分类：  59
//#高位 lui auipc
//#加载 lb lh lw ld (lbu lhu lwu)u 
//#保存 sb sh sw sd
//#加减 add sub (addw subw addi addiw)wi
//#比较 slt (sltu slti sltiu)ui 
//#门电 and or xor (andi ori xori)i 
//#位移 sll srl sra (sllw srlw sraw)w (slli srli srai slliw srliw sraiw)i
//#条件 beq bne blt bge (bltu bgeu)u
//#跳转 jal jalr
// 异常 ecall 
// 中断 ebreak 
// 保护 fence fence.i
// 控制 csrrw csrrs csrrc (csrrwi csrrsi csrrci)i



//// -------Privileged-----------------
// 0001000 00010 00000 000 00000 1110011 SRET *
// 0011000 00010 00000 000 00000 1110011 MRET *
// 0001000 00101 00000 000 00000 1110011 WFI //wait for interrupt
URET
CSR..
SFENCE.VMA supervisor fence virtual memory address




// Test Instruction Little Endian
//10110111 00010000 00000000 00000000 // 00000000 00000000 00010000 10110111 //_____00000000000000000001_00001_0110111 // LUI lsh1 12  to x1

////00000000 00000000 00000000 10010111 //_____00000000000000000000_00000_0010111 // AUIPC lsh1 12 + pc to x1
//00000011 00000001 00000000 00000000 //00000000 00000000 00000001 00000011 //___000000000001_00000_000_00010_0000011 // LB load x0+0 b to x2
//00000011 01000001 00000000 00000000 //00000000 00000000 01000001 00000011 //___000000000000_00000_100_00010_0000011 // LBU load x0+0 ub to x2
//00000011 00010001 00000000 00000000 //00000000 00000000 00010001 00000011 //___000000000000_00000_001_00000_0000011 // LH load x0+0 h to x2 
//00000011 01010001 00000000 00000000 //00000000 00000000 01010001 00000011 //___000000000000_00000_101_00000_0000011 // LHU load x0+0 uh to x2 
//00000011 00100001 00000000 00000000 //00000000 00000000 00100001 00000011 //___000000000000_00000_010_00000_0000011 // LW load x0+0 w to x2 
//00000011 01100001 00000000 00000000 //00000000 00000000 01100001 00000011 //___000000000000_00000_110_00000_0000011 // LWU load x0+0 w to x2  
//00000011 00110001 01000000 00000000 //00000000 01000000 00110001 00000011 //___000000000000_00000_011_00000_0000011 // LD load x0+4 dw to x2 

//10100011 00000000 00100000 00000000 //0000000_0 0010_0000 0_000_0000 10100011 //_0000000_00010_00000_000_00001_0100011// SB L8 x2 to x0+1 data
//10000011 00000000 00010000 00000000 //00000000 00010000 00000000 1_0000011 //___000000000001_00000_000_00001_0000011 // LB load x0+1 B to x1
//10000011 00000000 00100000 00000000 //00000000 00010000 00000000 1_0000011 //___000000000010_00000_000_00001_0000011 // LB load x0+2 B to x1
//10100011 00010000 00100000 00000000 //00000000 0010_0000 0_001_0000 1_0100011 //___000000000010_00000_001_00001_0100011 // SH L16 x2 to x0+1 data
//10000011 00000000 00100000 00000000 //00000000 00010000 00000000 1_0000011 //___000000000010_00000_000_00001_0000011 // LB load x0+2 B to x1
//10000011 00010000 00010000 00000000 //00000000 00010000 00010000 10000011 //___000000000001_00000_001_00001_0000011 // LH load x0+1 H to x1 
//10000011 01010000 00010000 00000000 //00000000 00010000 01010000 10000011 //___000000000001_00000_101_00001_0000011 // LHU load x0+1 UH to x1 
//
//10100011 00100000 00100000 00000000 //_0000000_0 0010_0000 0_010_0000 1_0100011 //___0000000_00010_00000_010_00001_0100011 // SW L32 x2 to x0+1 data  
//10000011 00100000 00010000 00000000 // 00000000 0001_0000 0_010_0000 1_0000011  //___000000000001_00000_010_00001_0000011 // LW load x0+1 W to x1
//
//10100011 00110000 00100000 00000000 //00000000 00100000 00110000 10100011 //___0000000_00010_00000_011_00001_0100011 // SD L64 x2 to x0+1 data  
//10000011 00110000 00010000 00000000 //00000000 00010000 00110000 10000011 //___000000000001_00000_011_00001_0000011 // LD load x0+1 DW to x1 

10000011 00100000 00000000 00000000 // 00000000 0000_0000 0_010_0000 1_0000011  //___000000000000_00000_010_00001_0000011 // LW load x0+0 W to x1
00000011 00100001 01000000 00000000 // 00000000 0100_0000 0_010_0001 0_0000011  //___000000000100_00000_010_00010_0000011 // LW load x0+4 W to x2
10110011 10000000 00100000 00000000 //00000000 00100000 10000000 10110011 //__0000000_00010_00001_000_00001_0110011 // ADD x1, x1, x2
00000011 00100001 01000000 00000000 // 00000000 0100_0000 0_010_0001 0_0000011  //___000000000100_00000_010_00010_0000011 // LW load x0+4 W to x2



//10000011 00100000 00000000 00000000 // 00000000 0000_0000 0_010_0000 1_0000011  //___000000000000_00000_010_00001_0000011 // LW load x0+0 W to x1
//00000011 00100001 01000000 00000000 // 00000000 0100_0000 0_010_0001 0_0000011  //___000000000100_00000_010_00010_0000011 // LW load x0+4 W to x2
//10110011 10000000 00100000 01000000 //__0100000_0 0010_0000 1_000_0000 1_0110011 //__0100000_00010_00001_000_00001_0110011 // SUB  x1 - x2 => x1


//10000011 00100000 00000000 00000000 // 00000000 0000_0000 0_010_0000 1_0000011  //___000000000000_00000_010_00001_0000011 // LW load x0+0 W to x1
//00000011 00100001 01000000 00000000 // 00000000 0100_0000 0_010_0001 0_0000011  //___000000000100_00000_010_00010_0000011 // LW load x0+4 W to x2
//10110011 10100000 00100000 00000000 // 00000000 00100000 10100000 10110011 //__0000000_00010_00001_010_00001_0110011 // SLT  x1 < x2 -> x1=1



//00000000 00000000 00010000 10110111 //_____00000000000000000001_00001_0110111 // LUI lsh1 12  to x1
//00000000 00000000 00000000 00001111 //_0000_0000_0000_00000_000_00000_0001111 // FENCE 
//00000000 00100000 00000000 11101111 //__0_0000000001_0_00000000_00001_1101111 // JAL   
//00000000 00000000 10000000 01100111 //___000000000000_00001_000_00000_1100111 // JALR  
//00000000 00000000 00000000 00001111 //_0000_0000_0000_00000_000_00000_0001111 // FENCE 


//伪指令 60 条（ 32 条 x0, 28 条 no-x0）
//-
*//nop: addi x0, x0, 0 空操作
*//neg rd, rs: sub rd, x0, rs 取负
*//negw rd, rs: subw rd, x0, rs 取负字（32bit)
*//snez rd, rs: sltu rd, x0, rs 不为 0 时置位 (x0 < rs)
*//sltz rd, rs: slt rd, rs, x0 小于 0 时置位（rs < x0）
*//sgtz rd, rs: slt rd, x0, rs 大于 0 时置位（x0 < rs）
*//beqz rs, offset: beq rs, x0, offset 等于 0 时分支（rs == x0)
*//bnez rs, offset: bne rs, x0, offset 不于 0 时分支（rs != x0)
*//blez rs, offset: bge x0, rs, offset 小于等于 0 时分支（rs <= x0）
*//bgez rs, offset: bge rs, x0, offset 大于等于 0 时分支（rs >= x0）
*//bltz rs, offset: blt rs, x0, offset 小于 0 时分支（rs < x0） 
*//bgtz rs, offset: blt x0, rs, offset 大于 0 时分支（rs > x0）
*//j offset: jal x0, offset PC(pc+imm)跳转（返回地址 pc+4 写入 x0 无效）
*//jr rs: jalr x0, rs, 0 寄存器(rs+imm)跳转（返回地址 pc+4 写入 x0 无效）
*//ret: jalr x0, x1, 0 从子过程中返回（子函数返回）
*//tail offset: auipc x6, offset[32:12]; jalr x0, x6, offset[11:0] 尾调用远距离子过程
//-
//rdinstret[h] rd: csrrs rd, instret[h], x0 读已提交指令计数器
//rdcycle[h] rd: csrrs rd, cycle[h], x0 读周期计数器
//rdtimeh[h] rd: csrrs rd, time[h], x0 读实时时钟
//-
//csrr rd,csr:CSR 读
//csrw csr, rs: CSR 写
//csrs csr, rs: CSR 置位
//csrc csr, rs: CSR 清位
//csrwi csr, imm: CSR写立即数
//csrsi csr, imm: CSR置位立即数
//csrci csr, imm: CSR清位立即数
//-
//frcsr rd: 读浮点 csr 寄存器
//fscsr rs: 写浮点 csr 寄存器
//frrm rd: 读浮点写入模式
//fsrm rs: 写浮点写入模式
//frflags rd: 读浮点异常标识
//fslags rs: 写浮点异常标识
//-- no-x0
*//lla rd, symbol: auipc rd, symbol[31:12]; add rd, rd, symbol[11:0] 装入局部地址 ??
*0//la rd, symbol: auipc rd, GOT[symbol][31:12]; l{w|d}rd, GOT[symbol][11:0](rd) 装入地址（GOT: Global Offset Table) ??  hi = (offset + 0x800) >>12; lo = offset - (hi <<12)
*0//l{b|h|w|d} rd, symbol: auipc rd, symbol[31:12]; l{b|h|w|d} rd, symbol[11:0](rd) 读全局符号
*0//s{b|h|w|d} rd, symbol, rt: auipc rt, symbol[31:12]; s{b|h|w|d} rd, symbol[11:0](rt) 写全局符号
//fl{w|d} rd, symbol, rt: 读全局浮点符号
//fs{w|d} rd, symbol, rt: 写全局浮点符号
*//li rd, imm: 装入立即数
*//mv rd,rs: addi rd, rs, 0 复制寄存器
*//not rd, rs: xori rd, rs, -1 取反
//sext.w rd, rs: addiw rd, rs, 0 符号字扩展
*//seqz rd, rs: sltiu rd, rs, 1 等于 0 时置位
//fmv.s rd, rs: 复制单精度寄存器
//fabs.s rd, rs:单精度浮点绝对值
//fneg.s rd, rs:单精度浮点相反数
//fmv.d rd, rs:复制双精度寄存器
//fabs.d rd, rs:双精度浮点绝对值
//fneg.d rd, rs:双精度浮点相反数
*//bgt rs, rt, offset: blt rt, rs, offset 大于时分支
*//ble rs, rt, offset: bge rt, rs, offset 小于等于时分支
*//bgtu rs, rt, offset: bltu rt, rs, offset 无符号大于时分支
*//bleu rs, rt, offset: bgeu rt, rs, offset 无符号小于等于时分支
*//jal offset: jal x1, offset 跳转并链接(jar x1, imm is real)
*//jalr rs: jalr x1, rs, 0 寄存器跳转并链接(jalr x1, x5, imm; jalr offset(rs1)?? is real)
*//call offset: auipc x1, offset[31:12]; jalr x1, offset[11:0](x1) 调用远距离过程
//fence: fence iorw, iorw 内存和 I/O 屏障
//fscsr rd, rs: csrrw rd, fcrs, rs 交换浮点 csr 寄存器
//fsrm rd, rs: csrrw rd, frm, rs 交换浮点舍入模式
//fsflags rd, rs: csrrw rd, fflags, rs 交换浮点异常模式




// 伪指令汇编测试
//#LI













LUI check 12 bit if 1 hi20+1 then addi lo12 else 0 hi20 addi lo12;
We intent to plus x, but is minus y, since x+y=10, we plus 10 and let it minus y, 10-y=x, we plus x;
when overflow by +10, the -y draw it back.

LUI always based on a 32-bit signed number to do his upper moving and sign-extending.
LI just put the number into register without sign-extending.

